Представлено два решения в ветках solution-1 и solution-2. 

В решении solution-1 представлено минимально необходимое (_на мой взгляд_) решение: выполнено 3 таска, указанные в описании задания.
Пересмотрена структура кода. Из класса Flight выделен в отдельный класс Segment. FlightBuilder теперь внутренний класс Flight.
Переопределены области видимости классов и их составляющих (иначе нельзя было составить юнит тесты + на мой взгляд такая структура более читаема).
Добавлен класс FlightFilterService, который выполняет необходимую бизнес логику.

В рамках данного решения представлены фиксированный набор фильтров. Под динамическим выбором фильтров - подразумеваю выбор
конкретных фильтров + написание нужных фильтров с учетом новых бизнес требований.

Наборы перелетов могут быть очень большими - для работы с большими данным, я бы:
1. Запретил записывать перелеты с некорректными сегментами (когда отправление происходит позже чем прибытие) -> решаем проблемы изначально, а не работаем с некорректными данными (проверка при вводе)
2. Использовал пагинацию (при рассмотрении того случая, когда перелеты считываются из БД). Ограничив по дате (можно также меняя порядок перечисления)
3. Продумал бы, какая последовательность фильтров дает наиболее оптимальный алгоритм сортировки (если фильтр1 отсеет большую часть перелетов,
а фильтр2 лишь малую часть, то эффективнее сначала использовать фильтр1)

По заданию сторонние библиотеки использовать не нужно. Использовал только одну: Junit.
