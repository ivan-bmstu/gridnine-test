Представлено два решения в ветках solution-1 и solution-2.

В решении solution-2 я расширил solution-1. Помимо указанной в задании функциональности, я продумал, какие основные фильтры нужны потенциальному юзеру:
- отфильтровать перелеты по дате отправления (в период между датами)
- отфильтровать перелеты по дате прибытия (в период между датами)
- отфильтровать перелеты по количеству пересадок (пересадок <= x)
- отфильтровать перелеты по продолжительности времени ожидания на земле (время на земле <= x минут)

Некорректные перелеты (прилет раньше чем вылет) фильтруются изначально и не отображаются юзеру

В solution-2 сделал имитацию обращения к "серверу" через консоль. Сервер "расположен" по адресу www.gridnine.com, нужный ресурс - www.gridnine.com/testing/flights
Доступные параметры запроса описаны в методе help() в классе Main.

В рамках данного решения представлен некоторый минимально необходимый набор фильтров. Под динамическим выбором фильтров - подразумеваю выбор
конкретных фильтров в рамках параметров "http запроса". При расширении модели Flight или появления новых бизнес требований набор фильтров может быть расширен.

Запросы по типу отправление позже прибытия (если так указаны параметры фильтров в запросе) я специальном образом не отсеивал (чтобы не делать слишком много кода в рамках одного класса).
Для эффективной работы с большим количеством перелетов конечно такие запросы нужны изначально отсеивать и не фильтровать, чтобы попусту не тратить ресурсы сервера. Если нужно, могу дополнить :)


Наборы перелетов могут быть очень большими - для работы с большими данным, я бы:
1. Запретил записывать перелеты с некорректными сегментами (когда отправление происходит позже чем прибытие) -> решаем проблемы изначально, а не работаем с некорректными данными (проверка при вводе)
2. Использовал пагинацию (при рассмотрении того случая, когда перелеты считываются из БД). Ограничив по дате (можно также меняя порядок перечисления)
3. Продумал бы, какая последовательность фильтров дает наиболее оптимальный алгоритм сортировки (если фильтр1 отсеет большую часть перелетов,
   а фильтр2 лишь малую часть, то эффективнее сначала использовать фильтр1)

По заданию сторонние библиотеки использовать не нужно. Использовал только одну: Junit.
